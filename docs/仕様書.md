# 支出記録アプリ（Expense Tracker）仕様書

## 1. 概要

支出記録アプリは、個人の日々の支出を簡単に記録・管理できるWebアプリケーションです。ユーザーは支出の金額、カテゴリ、日付、メモを入力し、一覧表示や合計金額の確認、データの編集・削除が可能です。ブラウザのlocalStorageを使用してデータを保存するため、ネット接続なしでも基本操作が可能です（localStorage使用）。

**技術的特徴**:
- 初期ロード目標: 80KB gzipped以下の軽量設計
- 複数タブ対応: storage イベントによる自動同期
- 耐障害性: 自動バックアップと復旧機能
- アクセシビリティ: WCAG 2.1 AA準拠

## 2. 目的

- 日々の支出を手軽に記録し、金銭管理の習慣を身につける
- カテゴリ別に支出を分類し、支出傾向を可視化する
- 過去の支出履歴を簡単に確認・検索できるようにする
- オフラインでも利用可能な軽量アプリケーションを提供する

## 3. 画面構成

### 3.1 メイン画面（単一ページ構成）

アプリは1つのHTMLページで構成され、以下のセクションで構成されます。

#### ヘッダー部
- アプリケーションタイトル「支出記録アプリ」
- 現在の総支出額の表示

#### 入力フォーム部
- 金額入力欄（必須）
- カテゴリ選択欄（必須）
- 日付入力欄（必須、デフォルト: 今日の日付）
  - **日付ショートカットボタン**: 「今日」「昨日」「先週末」
  - ボタンクリックで該当日付を自動入力
  - 「先週末」= 直近の土曜日
- メモ入力欄（任意）
- 「追加」ボタン

#### フィルター・ソート部
- カテゴリフィルター（すべて/特定カテゴリ）
- 期間フィルター（すべて/今月/先月/カスタム）
- **検索ボックス**（任意、メモ・カテゴリ名で部分一致検索）
- ソート順（日付降順/日付昇順/金額降順/金額昇順/カテゴリ順）

**フィルター・ソート評価順序**（重要）:
1. 期間フィルター適用
2. カテゴリフィルター適用
3. 検索クエリ適用（任意）
4. ソート処理実行

**詳細仕様**:
- 期間「今月」「先月」: Asia/Tokyo タイムゾーンの暦月で算出
- カテゴリ順ソート: カテゴリマスタ定義順（food → transport → entertainment → utilities → other）
- 安定ソート: 同一ソートキー（同額・同日）の場合は `createdAt` 降順（新しい順）でセカンダリソート
- **検索機能**: メモ内容とカテゴリ名（日本語名）で部分一致検索
  - 例: 「食」で検索 → 「食費」カテゴリと「食事」を含むメモがヒット
  - 大文字小文字を区別しない（case-insensitive）
  - 空白はOR検索として扱う（オプション）
- フィルター/ソート変更は300msデバウンス処理
- **設定の永続化**: 直近のソート条件とフィルター設定をlocalStorageに保存し、次回起動時に復元

#### 支出リスト部
- 支出データの一覧表示（テーブルまたはカード形式）
- 各項目に編集・削除ボタン
- フィルター適用後の合計金額表示
- **データが0件の場合**: 「最初の支出を追加しましょう」メッセージ + ダミーデータ挿入ボタン表示

**メモの省略表示**:
- 1行表示、最大30文字で省略（超過時は「...」）
- 「全文」ボタンをクリックでモーダル表示
- モーダル内容: 改行保持、URL自動リンク無効
- モーダル閉じる: Escキーまたは閉じるボタン

#### フッター部
- データ全削除ボタン
- **CSVエクスポートボタン**（v1.3実装）
- データインポート機能（v1.4以降で実装予定）

## 4. 入出力仕様

### 4.1 入力仕様

#### 支出データ入力
| 項目 | 型 | 必須 | 制約 | デフォルト値 |
|------|------|------|------|--------------|
| 金額 | number | ○ | 正の整数（1〜9,999,999円） | - |
| カテゴリ | string | ○ | カテゴリID（food/transport/entertainment/utilities/other） | food |
| 日付 | date | ○ | YYYY-MM-DD形式、今日以前の日付 | 今日の日付 |
| メモ | string | - | 最大100文字（厳密） | 空文字 |

#### バリデーションルール詳細

##### 金額入力
- **受理形式**: 半角整数のみを受理
  - 入力時に以下を自動正規化:
    - 全角数字 → 半角数字に変換
    - カンマ（`,`） → 除去
    - 空白文字 → 除去
  - 例: 「1,２３4 5」→ 正規化後「12345」→ バリデーション実行
- **範囲制約**: 1円以上、9,999,999円以下
  - 0円は不可
  - 負数は不可
  - 小数点以下は不可
- **エラー処理**:
  - バリデーション失敗時は保存を実行しない
  - 金額入力フィールドの直下に赤文字でエラーメッセージを表示
  - エラーメッセージ例:
    - 「金額は1円以上9,999,999円以下で入力してください」
    - 「金額は整数で入力してください」
  - エラー表示中は入力フィールドに赤枠を表示

##### カテゴリ選択
- **データ保存形式**: カテゴリID（英数字識別子）で保存
  - 保存例: `"food"`, `"transport"`, `"entertainment"`, `"utilities"`, `"other"`
- **UI表示**: 日本語名称とアイコンを組み合わせて表示
  - 表示例: 「🍽️ 食費」
- **フォールバック処理**:
  - データ読み込み時に未知のカテゴリIDが見つかった場合、`"other"`（その他）として扱う
  - 将来の多言語対応やカテゴリ追加を考慮した設計
- **国際化対応**: カテゴリIDは言語非依存のため、多言語対応時も安定

##### 日付入力
- **制約**: 今日以前の日付のみ受理（未来日不可）
- **日付判定基準**: Asia/Tokyo タイムゾーンのローカル日付境界で判定
  - 判定ロジック例:
    ```javascript
    const today = new Date().toLocaleDateString('ja-JP', { timeZone: 'Asia/Tokyo' });
    const inputDate = new Date(inputValue).toLocaleDateString('ja-JP', { timeZone: 'Asia/Tokyo' });
    if (inputDate > today) {
      // エラー: 未来日
    }
    ```
- **未来日のエラー処理**:
  - 未来日が入力された場合、保存を実行しない
  - 日付入力フィールドの直下にエラーメッセージを表示
  - エラーメッセージ: 「未来日は登録できません」
  - エラー表示中は入力フィールドに赤枠を表示
- **デフォルト動作**: ページ読み込み時、日付フィールドに今日の日付を自動設定

##### メモ入力
- **文字数制限**: 最大100文字（厳密）
- **リアルタイムカウンタ表示**:
  - メモ入力フィールドの下部に「○○/100文字」と表示
  - 入力時にリアルタイムで更新
  - 100文字以内: 通常色（グレー）
  - 100文字超過: 警告色（赤）
- **超過時の処理**:
  - 100文字を超えた場合、保存を実行しない（サイレント切り捨ては禁止）
  - エラーメッセージ: 「メモは100文字以内で入力してください（現在：○○文字）」
  - エラー表示中は入力フィールドに赤枠を表示
- **入力可能文字**: すべてのUnicode文字（絵文字含む）
  - 文字数カウントはJavaScriptの文字列長（`string.length`）で判定
  - サロゲートペア対応を考慮する場合は `Array.from(string).length` を使用

#### 総合バリデーション
- すべての必須項目が入力され、すべてのバリデーションをパスした場合のみ「追加」ボタンを有効化（推奨）
- または、バリデーションエラーがある状態で「追加」ボタンをクリックした場合、該当するすべてのエラーメッセージを表示

### 4.2 出力仕様

#### 支出リスト表示
- 各支出項目を以下の形式で表示:
  - 日付（YYYY年MM月DD日）
  - カテゴリ（アイコン付き）
  - 金額（カンマ区切り、円表示）
  - メモ（省略表示、クリックで全文表示）
  - 操作ボタン（編集/削除）

#### 合計金額表示
- 全支出の合計: ヘッダーに大きく表示
- フィルター適用後の合計: リスト下部に表示
- カンマ区切り、円表示

#### フィードバックメッセージ（トースト通知）
トースト通知は画面右上または下部に表示され、ARIA live領域として実装します。

- **成功**: 「支出を追加しました」
  - 色: 緑色（#4CAF50）
  - 表示時間: 3秒間
  - ARIA: `role="status"` `aria-live="polite"`
- **編集**: 「支出を更新しました」
  - 色: 青色（#2196F3）
  - 表示時間: 3秒間
  - ARIA: `role="status"` `aria-live="polite"`
- **削除**: 「支出を削除しました」
  - 色: オレンジ色（#FF9800）
  - 表示時間: 5秒間
  - **「取り消し」ボタン付き**: 5秒以内にクリックで削除を元に戻す
  - ARIA: `role="status"` `aria-live="polite"`
- **エラー**: 「入力内容を確認してください」または具体的なエラー内容
  - 色: 赤色（#F44336）
  - 表示時間: 5秒間
  - ARIA: `role="alert"` `aria-live="assertive"`

**実装要件**:
- トースト通知はスタック可能（複数同時表示対応）
- フェードイン・フェードアウトアニメーション
- クリックまたはタップで手動で閉じることが可能
- キーボードフォーカス管理（閉じるボタンにフォーカス可能）

## 5. 機能一覧

### 5.1 基本機能

#### F-01: 支出の追加
- 入力フォームから支出データを追加
- 入力値のバリデーション
- localStorageへの保存
- リストへの即時反映
- フォームのリセット

#### F-02: 支出の一覧表示
- 保存された全支出データの表示
- 日付降順でのデフォルト表示
- カテゴリ別アイコン表示
- データが0件の場合のメッセージ表示

#### F-03: 支出の編集
- 編集ボタンクリックで該当データをフォームに読み込み
- データ更新後の保存
- リストの再描画

#### F-04: 支出の削除
- 削除ボタンクリックで即座に削除実行（**確認ダイアログなし**）
- 削除後、5秒間「取り消し」ボタン付きトースト通知を表示
- 「取り消し」クリックでバックアップから復元
- **設計思想**: 確認ダイアログは冗長で操作を妨げる。Undoによる可逆性の方がユーザー体験が快適
- バックアップは削除前に自動作成
- リストの再描画
- 合計金額の再計算

#### F-05: 合計金額の計算・表示
- 全支出の合計金額をリアルタイム計算
- ヘッダーに常時表示
- フィルター適用時は絞り込み後の合計も表示

### 5.2 拡張機能

#### F-06: フィルター機能
- カテゴリ別フィルタリング（すべて/特定カテゴリ選択）
- 期間別フィルタリング:
  - すべて: 全期間
  - 今月: Asia/Tokyo タイムゾーンの現在の暦月
  - 先月: Asia/Tokyo タイムゾーンの前月
  - カスタム期間: 開始日・終了日を指定
- 検索機能（任意）:
  - メモ内容の部分一致検索（大文字小文字を区別しない）
  - カテゴリ名（日本語名）の部分一致検索
  - 例: 「食」で検索 → 「食費」カテゴリと「食事会」メモがヒット
- フィルター適用後の件数・合計金額表示
- **評価順序**: (1) 期間 → (2) カテゴリ → (3) 検索 → (4) ソート
- 300msデバウンス処理でパフォーマンス最適化
- **設定の永続化**:
  - フィルター設定をlocalStorageに保存（キー: `expenseTracker_filterSettings`）
  - 次回起動時に自動復元
  - 保存内容: カテゴリフィルター、期間フィルター、検索クエリ

#### F-07: ソート機能
- 日付順（昇順/降順）
- 金額順（昇順/降順）
- カテゴリ順（カテゴリマスタ定義順）
- **安定ソート**: 同一ソートキー（同額・同日）の場合は `createdAt` 降順（新しい順）をセカンダリソートとして適用
- ソート方向インジケータ（↑/↓アイコン）を表示
- **設定の永続化**:
  - ソート条件をlocalStorageに保存（キー: `expenseTracker_sortSettings`）
  - 次回起動時に自動復元
  - 保存内容: ソートキー（date/amount/category）、ソート方向（asc/desc）

#### F-08: データ管理機能
- 全データ削除（確認ダイアログ付き）
- **CSVエクスポート機能（v1.3実装）**:
  - エクスポートボタンで現在のデータをCSV形式でダウンロード
  - CSV形式: `日付,カテゴリ,金額,メモ`（ヘッダー行あり）
  - ファイル名: `expenses_YYYYMMDD.csv`（エクスポート日付を含む）
  - 文字コード: UTF-8 with BOM（Excel互換）
  - メモ内の改行・カンマはダブルクォートでエスケープ
  - カテゴリは日本語名で出力（IDではなく）
- **インポート機能**: 次期バージョン（v1.4以降）で対応予定
- データのバックアップ機能（既存: バックアップキーへの自動保存）

#### F-09: カテゴリ統計表示
- カテゴリ別の支出合計
- 円グラフまたは棒グラフでの可視化（将来拡張）

## 6. 使用技術

### 6.1 HTML5
- セマンティックHTML要素の使用
  - `<header>`: ヘッダー部
  - `<main>`: メインコンテンツ
  - `<form>`: 入力フォーム
  - `<section>`: 各セクション区分
  - `<table>` または `<ul>`: 支出リスト
- 入力要素
  - `<input type="number">`: 金額入力
  - `<select>`: カテゴリ選択
  - `<input type="date">`: 日付入力
  - `<textarea>`: メモ入力

### 6.2 CSS3
- レスポンシブデザイン
  - モバイルファーストアプローチ
  - メディアクエリ使用（768px、1024pxブレークポイント）
- レイアウト
  - Flexbox: ヘッダー、フォーム、ボタン配置
  - Grid: 支出リスト（デスクトップ版）
- スタイリング
  - カスタムCSSカラーパレット
  - ボタンのホバー・アクティブ状態
  - アニメーション（フェードイン、スライド）
  - カテゴリ別カラーコーディング
- フォント
  - システムフォントスタック使用
  - アイコンフォント検討（Font Awesome等）

### 6.3 JavaScript (ES6+)
- DOM操作
  - `querySelector`/`querySelectorAll`
  - `createElement`、`appendChild`
  - イベントリスナー（`addEventListener`）
- データ管理
  - オブジェクトと配列の操作
  - 配列メソッド（`map`、`filter`、`reduce`、`sort`）
  - UUID v4 生成（ID管理）
- ストレージ
  - localStorage API
  - storage イベント（複数タブ同期）
  - JSON.stringify/JSON.parse
- 国際化（i18n）
  - `Intl.DateTimeFormat('ja-JP', { timeZone: 'Asia/Tokyo' })`: 日付フォーマット
  - `Intl.NumberFormat('ja-JP', { style: 'currency', currency: 'JPY' })`: 通貨フォーマット
- モジュール構成（推奨）
  - StorageAdapter: データアクセス抽象化
  - データ管理モジュール
  - UI更新モジュール
  - ユーティリティモジュール
- エラーハンドリング
  - try-catchブロック
  - バリデーション関数
  - ストレージエラー処理（quota_exceeded/unavailable/corrupted_json）
- キーボードショートカット
  - Enter: フォーカスがフォーム内の時のみ登録実行
  - Escape: モーダル閉じる
  - `/`: 検索フォーカス（オプション）
- 日付入力ショートカット
  - 日付入力欄近くに「今日」「昨日」「先週末」ボタンを配置
  - ボタンクリックで該当日付を自動入力し、入力効率を向上
- アクセシビリティ
  - ARIA属性: `aria-label`, `aria-labelledby`, `aria-describedby`, `aria-invalid`, `aria-live`, `role`
  - WCAG 2.1 AA準拠のコントラスト比

## 7. データ構造（localStorage利用）

### 7.1 ストレージキー
```
"expenseTracker_expenses"        : 支出データ配列（現行データ）
"expenseTracker_expenses_bak"    : 支出データ配列（バックアップ、直近1世代）
"expenseTracker_schemaVersion"   : スキーマバージョン（例: "1.3"）
"expenseTracker_filterSettings"  : フィルター設定（カテゴリ、期間、検索クエリ）
"expenseTracker_sortSettings"    : ソート設定（キー、方向）
```

**注意事項**:
- `expenseTracker_nextId` は廃止（UUID v4採用により不要）
- 既存データとの互換性が必要な場合、マイグレーション処理でUUIDへ変換
- バックアップは書き込み時に世代交代（現行 → バックアップ → 新規書き込み）
- 設定系データ（filter/sort）はJSON形式で保存

### 7.2 支出データオブジェクト構造

```javascript
{
  id: string,           // UUID v4（例: "550e8400-e29b-41d4-a716-446655440000"）
  amount: number,       // 金額（円、内部は数値で保持）
  category: string,     // カテゴリID（例: "food", "transport"）
  date: string,         // 日付（YYYY-MM-DD形式、ISO 8601）
  memo: string,         // メモ（最大100文字）
  createdAt: string,    // 作成日時（ISO 8601形式、UTC）
  updatedAt: string     // 更新日時（ISO 8601形式、UTC）
}
```

**フィールド詳細説明**:
- `id`: UUID v4で生成。複数タブでの採番競合を回避
- `amount`: 内部は数値型で保持。表示時に `Intl.NumberFormat` で通貨フォーマット
- `category`: カテゴリIDを文字列で保存。表示時に `getCategoryById()` で名称・アイコン・色を取得
- `date`: YYYY-MM-DD形式。タイムゾーン情報は含まない（ローカル日付として扱う）
- `createdAt`, `updatedAt`: UTC基準のISO 8601形式。同期機能での競合解決、編集競合検知に使用

### 7.3 データ例

```javascript
[
  {
    id: "550e8400-e29b-41d4-a716-446655440000",
    amount: 1200,
    category: "food",
    date: "2025-10-22",
    memo: "ランチ",
    createdAt: "2025-10-22T03:30:00.000Z",  // UTC時刻
    updatedAt: "2025-10-22T03:30:00.000Z"
  },
  {
    id: "6ba7b810-9dad-11d1-80b4-00c04fd430c8",
    amount: 3500,
    category: "transport",
    date: "2025-10-21",
    memo: "電車定期券",
    createdAt: "2025-10-21T00:15:00.000Z",
    updatedAt: "2025-10-21T00:15:00.000Z"
  },
  {
    id: "7c9e6679-7425-40de-944b-e07fc1f90ae7",
    amount: 8000,
    category: "entertainment",
    date: "2025-10-20",
    memo: "映画とディナー",
    createdAt: "2025-10-20T10:45:00.000Z",
    updatedAt: "2025-10-20T10:45:00.000Z"
  }
]
```

**注意**: 
- `id` フィールドはUUID v4形式
- `amount` は数値型で保存（表示時に通貨フォーマット）
- `category` フィールドはカテゴリID（`"food"`, `"transport"` 等）で保存され、UI表示時にカテゴリマスタから名称とアイコンを取得します

### 7.4 カテゴリマスタ

カテゴリはID（英数字識別子）で管理し、表示名とアイコンは分離して定義します。これにより多言語対応が容易になります。

**推奨**: 将来の拡張を考慮し、カテゴリマスタは外部ファイル（`categories.json`）として定義し、アプリケーション起動時に読み込む設計を推奨します。

```javascript
// categories.json（外部定義例）
[
  { 
    "id": "food", 
    "name": "食費",
    "name_en": "Food",
    "icon": "🍽️", 
    "color": "#FF6B6B",
    "order": 1
  },
  { 
    "id": "transport", 
    "name": "交通費",
    "name_en": "Transportation",
    "icon": "🚗", 
    "color": "#4ECDC4",
    "order": 2
  },
  { 
    "id": "entertainment", 
    "name": "娯楽",
    "name_en": "Entertainment",
    "icon": "🎮", 
    "color": "#95E1D3",
    "order": 3
  },
  { 
    "id": "utilities", 
    "name": "光熱費",
    "name_en": "Utilities",
    "icon": "💡", 
    "color": "#FFE66D",
    "order": 4
  },
  { 
    "id": "other", 
    "name": "その他",
    "name_en": "Other",
    "icon": "📦", 
    "color": "#A8DADC",
    "order": 5
  }
]

// JavaScriptでの読み込み（例）
let CATEGORIES = [];

async function loadCategories() {
  try {
    const response = await fetch('./categories.json');
    CATEGORIES = await response.json();
  } catch (error) {
    console.error('Failed to load categories:', error);
    // フォールバック: デフォルトカテゴリを使用
    CATEGORIES = [/* デフォルト定義 */];
  }
}

// カテゴリIDから表示情報を取得するヘルパー関数
function getCategoryById(categoryId) {
  const category = CATEGORIES.find(cat => cat.id === categoryId);
  // 未知のIDの場合は "other" にフォールバック
  return category || CATEGORIES.find(cat => cat.id === "other");
}

// カテゴリ順ソート用の比較関数
function compareCategoryOrder(a, b) {
  const catA = getCategoryById(a.category);
  const catB = getCategoryById(b.category);
  return catA.order - catB.order;
}
```

**フィールド説明**:
- `id`: カテゴリID（英数字、言語非依存）
- `name`: 表示名（日本語）
- `name_en`: 表示名（英語、多言語対応時に使用）
- `icon`: 絵文字アイコン
- `color`: カテゴリ色（16進数カラーコード）
- `order`: ソート順序（昇順）

### 7.5 データ操作関数

#### 初期化
```javascript
function initializeStorage() {
  try {
    // スキーマバージョンチェック
    const currentVersion = localStorage.getItem("expenseTracker_schemaVersion");
    const targetVersion = "1.3";
    
    if (!currentVersion) {
      // 初回起動
      localStorage.setItem("expenseTracker_expenses", JSON.stringify([]));
      localStorage.setItem("expenseTracker_expenses_bak", JSON.stringify([]));
      localStorage.setItem("expenseTracker_schemaVersion", targetVersion);
    } else if (currentVersion !== targetVersion) {
      // バージョン違いの場合、マイグレーション実行
      migrateData(currentVersion, targetVersion);
    }
    
    // データ整合性チェック
    validateStorageData();
  } catch (error) {
    handleStorageError(error);
  }
}

// データ整合性チェック
function validateStorageData() {
  try {
    const data = localStorage.getItem("expenseTracker_expenses");
    JSON.parse(data); // JSON パースエラーチェック
  } catch (error) {
    console.error('Data corrupted, attempting recovery...', error);
    attemptDataRecovery();
  }
}
```

#### データ取得
```javascript
function getAllExpenses() {
  const data = localStorage.getItem("expenseTracker_expenses");
  return JSON.parse(data) || [];
}
```

#### データ追加（バリデーション含む）
```javascript
function addExpense(expenseData) {
  // 入力バリデーション
  const validationError = validateExpenseData(expenseData);
  if (validationError) {
    throw new Error(validationError);
  }
  
  try {
    const expenses = getAllExpenses();
    
    // バックアップ作成（世代交代）
    createBackup(expenses);
    
    const newExpense = {
      id: generateUUID(),  // UUID v4 生成
      amount: expenseData.amount,
      category: expenseData.category,  // カテゴリIDで保存
      date: expenseData.date,
      memo: expenseData.memo || "",
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    
    expenses.push(newExpense);
    localStorage.setItem("expenseTracker_expenses", JSON.stringify(expenses));
    
    return newExpense;
  } catch (error) {
    handleStorageError(error);
    throw error;
  }
}

// UUID v4 生成関数
function generateUUID() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0;
    const v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

// バックアップ作成
function createBackup(currentData) {
  try {
    localStorage.setItem("expenseTracker_expenses_bak", JSON.stringify(currentData));
  } catch (error) {
    console.warn('Failed to create backup:', error);
    // バックアップ失敗は警告のみ（処理は継続）
  }
}

// バリデーション関数
function validateExpenseData(data) {
  // 金額バリデーション
  const amount = normalizeAmount(data.amount);
  if (!Number.isInteger(amount) || amount < 1 || amount > 9999999) {
    return "金額は1円以上9,999,999円以下の整数で入力してください";
  }
  
  // カテゴリバリデーション
  const validCategoryIds = CATEGORIES.map(cat => cat.id);
  if (!validCategoryIds.includes(data.category)) {
    return "有効なカテゴリを選択してください";
  }
  
  // 日付バリデーション（未来日チェック）
  const today = new Date().toLocaleDateString('ja-JP', { timeZone: 'Asia/Tokyo' });
  const inputDate = new Date(data.date).toLocaleDateString('ja-JP', { timeZone: 'Asia/Tokyo' });
  if (inputDate > today) {
    return "未来日は登録できません";
  }
  
  // メモバリデーション
  if (data.memo && Array.from(data.memo).length > 100) {
    return `メモは100文字以内で入力してください（現在：${Array.from(data.memo).length}文字）`;
  }
  
  return null; // バリデーション成功
}

// 金額正規化関数
function normalizeAmount(input) {
  // 文字列の場合、全角数字を半角に変換し、カンマと空白を除去
  if (typeof input === 'string') {
    const normalized = input
      .replace(/[０-９]/g, (s) => String.fromCharCode(s.charCodeAt(0) - 0xFEE0))  // 全角→半角
      .replace(/,/g, '')   // カンマ除去
      .replace(/\s/g, ''); // 空白除去
    return parseInt(normalized, 10);
  }
  return parseInt(input, 10);
}
```

#### データ更新（編集競合検知含む）
```javascript
function updateExpense(id, updatedData, originalUpdatedAt) {
  try {
    const expenses = getAllExpenses();
    const index = expenses.findIndex(exp => exp.id === id);
    
    if (index === -1) {
      throw new Error('指定されたデータが見つかりません');
    }
    
    // 編集競合チェック
    if (originalUpdatedAt && expenses[index].updatedAt !== originalUpdatedAt) {
      // 他のタブまたはユーザーが同時編集した場合
      throw new ConflictError('このデータは他の場所で更新されています', {
        current: expenses[index],
        attempted: updatedData
      });
    }
    
    // バックアップ作成
    createBackup(expenses);
    
    expenses[index] = {
      ...expenses[index],
      ...updatedData,
      updatedAt: new Date().toISOString()
    };
    
    localStorage.setItem("expenseTracker_expenses", JSON.stringify(expenses));
    return expenses[index];
  } catch (error) {
    if (error instanceof ConflictError) {
      // 競合エラーは呼び出し元で処理
      throw error;
    }
    handleStorageError(error);
    throw error;
  }
}

// 競合エラークラス
class ConflictError extends Error {
  constructor(message, data) {
    super(message);
    this.name = 'ConflictError';
    this.data = data;
  }
}

// 競合解決ダイアログ表示（UI側で実装）
function showConflictResolutionDialog(current, attempted) {
  // ユーザーに選択肢を提示:
  // 1. 上書き（attempted を保存）
  // 2. 破棄（current をそのまま使用）
  // 3. マージ（メモのみ、手動マージ）
  return new Promise((resolve) => {
    // UI実装例:
    // - 現在のデータと試行したデータを並べて表示
    // - ユーザーが選択したアクションを resolve で返す
  });
}
```

#### データ削除
```javascript
function deleteExpense(id) {
  try {
    const expenses = getAllExpenses();
    
    // バックアップ作成（Undo用）
    createBackup(expenses);
    
    const filtered = expenses.filter(exp => exp.id !== id);
    localStorage.setItem("expenseTracker_expenses", JSON.stringify(filtered));
    return true;
  } catch (error) {
    handleStorageError(error);
    throw error;
  }
}

// Undo（削除取り消し）
function undoDelete() {
  try {
    const backup = localStorage.getItem("expenseTracker_expenses_bak");
    if (backup) {
      localStorage.setItem("expenseTracker_expenses", backup);
      return true;
    }
    return false;
  } catch (error) {
    handleStorageError(error);
    return false;
  }
}
```

#### 全削除
```javascript
function clearAllExpenses() {
  try {
    // バックアップ作成
    const expenses = getAllExpenses();
    createBackup(expenses);
    
    localStorage.setItem("expenseTracker_expenses", JSON.stringify([]));
    return true;
  } catch (error) {
    handleStorageError(error);
    throw error;
  }
}
```

### 7.6 ストレージエラーハンドリング

localStorage利用不可、容量超過、データ破損などのエラーに対する耐障害性を確保します。

```javascript
// ストレージエラーハンドリング
function handleStorageError(error) {
  let errorCode = 'unknown';
  let errorMessage = 'データの保存に失敗しました';
  
  if (error.name === 'QuotaExceededError') {
    errorCode = 'quota_exceeded';
    errorMessage = 'ストレージ容量が不足しています';
  } else if (error.name === 'SecurityError') {
    errorCode = 'unavailable';
    errorMessage = 'ストレージが利用できません（プライベートブラウジングモード等）';
  } else if (error instanceof SyntaxError) {
    errorCode = 'corrupted_json';
    errorMessage = 'データが破損しています';
  }
  
  console.error(`[${errorCode}]`, errorMessage, error);
  
  // エラー画面表示
  showErrorScreen(errorCode, errorMessage);
}

// エラー画面表示
function showErrorScreen(errorCode, errorMessage) {
  const errorScreen = document.createElement('div');
  errorScreen.className = 'error-screen';
  errorScreen.setAttribute('role', 'alert');
  errorScreen.setAttribute('aria-live', 'assertive');
  
  errorScreen.innerHTML = `
    <div class="error-content">
      <h2>エラーが発生しました</h2>
      <p>${errorMessage}</p>
      <div class="error-actions">
        <button onclick="location.reload()">再読み込み</button>
        ${errorCode === 'quota_exceeded' ? '<button onclick="exportToCSV()">CSVエクスポート</button>' : ''}
        ${errorCode === 'corrupted_json' ? '<button onclick="attemptDataRecovery()">データ復旧を試す</button>' : ''}
      </div>
      <details>
        <summary>技術情報</summary>
        <p>エラーコード: <code>${errorCode}</code></p>
      </details>
    </div>
  `;
  
  document.body.appendChild(errorScreen);
}

// データ破損時の復旧
function attemptDataRecovery() {
  try {
    // バックアップから復元を試みる
    const backup = localStorage.getItem("expenseTracker_expenses_bak");
    
    if (backup) {
      JSON.parse(backup); // パースチェック
      
      // ユーザーに確認
      const confirmed = confirm(
        'バックアップデータから復元しますか？\n' +
        '（現在のデータは失われます）'
      );
      
      if (confirmed) {
        localStorage.setItem("expenseTracker_expenses", backup);
        location.reload();
        return true;
      }
    } else {
      // バックアップがない場合、初期化を提案
      showRecoveryOptions();
    }
  } catch (error) {
    console.error('Recovery failed:', error);
    showRecoveryOptions();
  }
  
  return false;
}

// 復旧オプション表示
function showRecoveryOptions() {
  const options = confirm(
    'バックアップデータが利用できません。\n\n' +
    'OK: データを初期化して最初から始める\n' +
    'キャンセル: 何もしない'
  );
  
  if (options) {
    localStorage.setItem("expenseTracker_expenses", JSON.stringify([]));
    localStorage.setItem("expenseTracker_expenses_bak", JSON.stringify([]));
    location.reload();
  }
}

// CSVエクスポート（容量超過時の救済策 & 通常機能）
function exportToCSV() {
  try {
    const expenses = getAllExpenses();
    const csv = convertToCSV(expenses);
    downloadCSV(csv, `expenses_${formatDateForFilename(new Date())}.csv`);
  } catch (error) {
    console.error('CSV export failed:', error);
    showToast('CSVエクスポートに失敗しました', 'error');
  }
}

// 支出データをCSV形式に変換
function convertToCSV(expenses) {
  // ヘッダー行
  const headers = ['日付', 'カテゴリ', '金額', 'メモ'];
  const rows = [headers];
  
  // データ行
  expenses.forEach(expense => {
    const category = getCategoryById(expense.category);
    const row = [
      expense.date,
      category.name,  // カテゴリIDではなく日本語名
      expense.amount,
      escapeCSVField(expense.memo || '')  // メモ内の改行・カンマをエスケープ
    ];
    rows.push(row);
  });
  
  // CSV文字列に変換
  const csvContent = rows.map(row => row.join(',')).join('\n');
  
  // UTF-8 with BOM（Excel互換）
  return '\uFEFF' + csvContent;
}

// CSVフィールドのエスケープ処理
function escapeCSVField(field) {
  // 改行、カンマ、ダブルクォートを含む場合はダブルクォートで囲む
  if (field.includes(',') || field.includes('\n') || field.includes('"')) {
    // ダブルクォートは2つ重ねてエスケープ
    return `"${field.replace(/"/g, '""')}"`;
  }
  return field;
}

// CSVファイルをダウンロード
function downloadCSV(csvContent, filename) {
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  
  if (link.download !== undefined) {
    // HTML5のdownload属性をサポートしている場合
    const url = URL.createObjectURL(blob);
    link.setAttribute('href', url);
    link.setAttribute('download', filename);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
    
    showToast('CSVファイルをダウンロードしました', 'success');
  } else {
    throw new Error('Download not supported');
  }
}

// ファイル名用の日付フォーマット（YYYYMMDD）
function formatDateForFilename(date) {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}${month}${day}`;
}
```

### 7.8 設定の永続化

フィルター・ソート設定をlocalStorageに保存し、次回起動時に復元します。

```javascript
// 設定データ構造
const defaultFilterSettings = {
  category: 'all',       // 'all' または カテゴリID
  period: 'all',         // 'all', 'thisMonth', 'lastMonth', 'custom'
  customStartDate: null,
  customEndDate: null,
  searchQuery: ''
};

const defaultSortSettings = {
  key: 'date',          // 'date', 'amount', 'category'
  direction: 'desc'     // 'asc', 'desc'
};

// フィルター設定を保存
function saveFilterSettings(settings) {
  try {
    localStorage.setItem('expenseTracker_filterSettings', JSON.stringify(settings));
  } catch (error) {
    console.warn('Failed to save filter settings:', error);
  }
}

// フィルター設定を読み込み
function loadFilterSettings() {
  try {
    const saved = localStorage.getItem('expenseTracker_filterSettings');
    return saved ? JSON.parse(saved) : defaultFilterSettings;
  } catch (error) {
    console.warn('Failed to load filter settings:', error);
    return defaultFilterSettings;
  }
}

// ソート設定を保存
function saveSortSettings(settings) {
  try {
    localStorage.setItem('expenseTracker_sortSettings', JSON.stringify(settings));
  } catch (error) {
    console.warn('Failed to save sort settings:', error);
  }
}

// ソート設定を読み込み
function loadSortSettings() {
  try {
    const saved = localStorage.getItem('expenseTracker_sortSettings');
    return saved ? JSON.parse(saved) : defaultSortSettings;
  } catch (error) {
    console.warn('Failed to load sort settings:', error);
    return defaultSortSettings;
  }
}

// 起動時に設定を復元
function restoreSettings() {
  const filterSettings = loadFilterSettings();
  const sortSettings = loadSortSettings();
  
  // UIに設定を反映
  applyFilterSettings(filterSettings);
  applySortSettings(sortSettings);
  
  // データをフィルター・ソート
  refreshExpenseList();
}

// フィルター変更時に保存
function onFilterChanged(newSettings) {
  saveFilterSettings(newSettings);
  refreshExpenseList();
}

// ソート変更時に保存
function onSortChanged(newSettings) {
  saveSortSettings(newSettings);
  refreshExpenseList();
}
```

### 7.9 日付入力ショートカット

日付入力を効率化するショートカットボタンの実装です。

```javascript
// 日付ショートカットボタンのイベントハンドラ
function setupDateShortcuts() {
  const dateInput = document.getElementById('date-input');
  
  // 「今日」ボタン
  document.getElementById('btn-today').addEventListener('click', () => {
    dateInput.value = formatDate(new Date());
  });
  
  // 「昨日」ボタン
  document.getElementById('btn-yesterday').addEventListener('click', () => {
    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    dateInput.value = formatDate(yesterday);
  });
  
  // 「先週末」ボタン（直近の土曜日）
  document.getElementById('btn-last-weekend').addEventListener('click', () => {
    const lastSaturday = getLastSaturday();
    dateInput.value = formatDate(lastSaturday);
  });
}

// YYYY-MM-DD形式にフォーマット
function formatDate(date) {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

// 直近の土曜日を取得
function getLastSaturday() {
  const today = new Date();
  const dayOfWeek = today.getDay(); // 0=日曜, 6=土曜
  
  let daysToSubtract;
  if (dayOfWeek === 0) {
    // 今日が日曜なら、昨日（土曜）
    daysToSubtract = 1;
  } else if (dayOfWeek === 6) {
    // 今日が土曜なら、先週の土曜
    daysToSubtract = 7;
  } else {
    // 月〜金なら、今週または先週の土曜
    daysToSubtract = dayOfWeek + 1;
  }
  
  const lastSaturday = new Date(today);
  lastSaturday.setDate(today.getDate() - daysToSubtract);
  return lastSaturday;
}
```

### 7.7 複数タブ対応と衝突回避

複数タブでアプリを開いている場合の同期と、データ競合の回避方法を定義します。

```javascript
// storage イベントで他タブの変更を検知
window.addEventListener('storage', (event) => {
  if (event.key === 'expenseTracker_expenses' && event.newValue !== null) {
    // 他のタブでデータが変更された
    console.log('Data changed in another tab, reloading...');
    
    // UI を即時更新
    const newExpenses = JSON.parse(event.newValue);
    renderExpenseList(newExpenses);
    updateTotalAmount(newExpenses);
    
    // トースト通知
    showToast('他のタブでデータが更新されました', 'info');
  }
});

// UUID v4 によるID競合回避（既に実装済み）
// 複数タブで同時に追加してもIDが重複しない

// 編集時の競合検知フロー
async function handleEditExpense(id) {
  const expense = getExpenseById(id);
  
  // 編集開始時の updatedAt を保持
  const originalUpdatedAt = expense.updatedAt;
  
  // 編集フォーム表示
  await showEditForm(expense);
  
  // 保存時に競合チェック
  try {
    await updateExpense(id, updatedData, originalUpdatedAt);
    showToast('支出を更新しました', 'success');
  } catch (error) {
    if (error instanceof ConflictError) {
      // 競合解決ダイアログ表示
      const resolution = await showConflictResolutionDialog(
        error.data.current,
        error.data.attempted
      );
      
      if (resolution === 'overwrite') {
        // 上書き（updatedAt チェックなし）
        await updateExpense(id, updatedData, null);
      } else if (resolution === 'discard') {
        // 破棄
        showToast('変更を破棄しました', 'info');
      } else if (resolution === 'merge') {
        // マージ（メモのみ）
        const merged = {
          ...error.data.current,
          memo: updatedData.memo
        };
        await updateExpense(id, merged, null);
      }
    } else {
      throw error;
    }
  }
}
```

## 8. 実装上の注意事項

### 8.1 セキュリティ
- **XSS対策**: 
  - ユーザー入力値を表示する際は常に`textContent`を使用、`innerHTML`は回避
  - URL自動リンク機能は無効化（v1.3時点）
  - 将来的にサニタイズが必要な場合はDOMPurifyなどのライブラリを使用
- **入力値のバリデーション**: クライアント側で厳密に実施（将来のサーバー側実装時も両方で実施）
- **Content Security Policy (CSP)**:
  - 最小限のCSP設定: `default-src 'self'`
  - インラインスクリプト/スタイルは`nonce`または`hash`を使用
  - 将来CDN導入時は明示的にホワイトリスト指定
  - HTMLヘッダー例: `Content-Security-Policy: default-src 'self'; style-src 'self' 'unsafe-inline'`
- **localStorage容量制限**: 約5MBの制限に対する適切なエラーハンドリング
- **将来の同期機能実装時**: CSRF対策、JWT/セッショントークン管理、HTTPS必須化

### 8.2 パフォーマンス
- **大量データ対応**:
  - リスト件数が1,000件超で仮想スクロール（Virtual Scroll）を有効化
  - ページネーション併用も検討（50件/ページ等）
- **DOM操作の最適化**:
  - DocumentFragmentの活用で再描画を最小化
  - 差分レンダリング（キー=ID）でDOM更新を最小限に
  - **UI反映目標**: 1操作あたり50ms以内でUI反映
- **デバウンス処理**: 
  - フィルター/ソート/検索の連打: 300msデバウンス
  - メモ文字数カウント: 100msデバウンス
- **初期ロード最適化**:
  - **目標**: 80KB gzipped以下
  - コード分割（Code Splitting）検討
  - 遅延ロード（Lazy Loading）でチャート等の非必須機能を分離
- **大量データ読み込み時**: ローディングインジケータ表示（500ms以上かかる場合）

### 8.3 ユーザビリティ
- **UI/UX設計**: 
  - マテリアルデザインまたはヒューマンインターフェイスガイドライン準拠
  - WCAG 2.1 AA準拠のコントラスト比（最低4.5:1）
- **フィードバックメッセージ**: 
  - 成功・エラー・警告を色と文言で明確に区別
  - トースト通知にARIA live属性を実装
  - **削除時のUndo機能**: 5秒間「取り消し」ボタンを表示
- **キーボード操作対応**:
  - **Enter**: フォーカスがフォーム内の時のみ登録実行
  - **Escape**: モーダル・ダイアログを閉じる
  - **`/`**: 検索フィールドにフォーカス（オプション）
  - **Tab**: 論理的なフォーカス順序で移動
- **アクセシビリティ**:
  - 適切なARIA属性（`aria-label`, `aria-labelledby`, `aria-describedby`, `aria-invalid`, `aria-live`, `role`）
  - すべての操作ボタンに`aria-label`を付与
  - スクリーンリーダー対応（読み上げ順序の最適化）
  - キーボードのみでの操作可能性
  - フォーカスインジケータの視認性確保
- **入力エラー時の明確な表示**: 
  - フィールド直下に具体的なエラーメッセージ
  - フィールドに赤枠ハイライト
  - `aria-invalid="true"` と `aria-describedby` でエラーメッセージを関連付け
- **空状態**: 
  - 「最初の支出を追加しましょう」メッセージ
  - ダミーデータ挿入ボタンで初回体験をサポート

### 8.4 バリデーション実装
- **クライアント側バリデーション**: リアルタイムフィードバックでUX向上
- **入力正規化**: 全角→半角、カンマ除去を送信前に実行
- **エラー表示**: 各フィールド直下に表示、まとめてトップに表示も検討
- **バリデーションタイミング**:
  - リアルタイム（入力中）: メモ文字数カウント
  - フォーカス喪失時（blur）: 金額・日付の妥当性チェック
  - 送信時: 全項目の最終バリデーション

### 8.5 日付・タイムゾーン処理
- **日付判定の一貫性**: Asia/Tokyo タイムゾーンで統一
- **UTC保存**: `createdAt`, `updatedAt` は UTC で保存（将来の同期機能対応）
- **表示時の変換**: 表示時にユーザーのタイムゾーンに変換
- **ライブラリ検討**: 複雑な日付操作が必要な場合は `date-fns` や `Day.js` の使用を検討

### 8.6 ブラウザ互換性
- モダンブラウザ対応（Chrome、Firefox、Safari、Edge最新版）
- localStorage未対応時の代替処理またはエラー表示
- モバイルブラウザでの動作確認（iOS Safari、Chrome Mobile）
- Polyfillの検討（古いブラウザをサポートする場合）

### 8.7 データ整合性とエラーハンドリング
- **localStorage書き込み失敗時のエラーハンドリング**:
  - エラーコード体系: `quota_exceeded`, `unavailable`, `corrupted_json`
  - わかりやすいエラー画面とリトライ・CSVエクスポート動線を表示
  - エラーログ出力（コンソール）
- **JSON.parseエラー時の復旧処理**:
  - 自動バックアップから復元（直近1世代）
  - 復元不可の場合、ユーザーに初期化/バックアップ読込の選択肢を提示
- **データ整合性チェック**: 
  - 起動時にJSON解析可能性をチェック
  - カテゴリIDの妥当性検証
  - 未知のカテゴリIDのフォールバック処理（`other`）
- **バックアップ戦略**:
  - 書き込み時に世代交代（現行 → バックアップ → 新規書き込み）
  - バックアップキー: `expenseTracker_expenses_bak`

## 9. 将来対応のための設計（軽量抽象化）

v1.2では、将来の拡張を見据えた軽量な抽象化層を導入します。

### 9.1 StorageAdapter インターフェース

データアクセス層を抽象化し、localStorageから他のストレージ（IndexedDB、クラウドDB等）への移行を容易にします。

```javascript
// StorageAdapter インターフェース定義
class StorageAdapter {
  async getAll() {
    throw new Error('Not implemented');
  }
  
  async add(expense) {
    throw new Error('Not implemented');
  }
  
  async update(id, data, originalUpdatedAt = null) {
    throw new Error('Not implemented');
  }
  
  async delete(id) {
    throw new Error('Not implemented');
  }
  
  async clear() {
    throw new Error('Not implemented');
  }
  
  async backup() {
    throw new Error('Not implemented');
  }
  
  async restore() {
    throw new Error('Not implemented');
  }
}

// LocalStorageAdapter 実装（現行）
class LocalStorageAdapter extends StorageAdapter {
  constructor() {
    super();
    this.storageKey = 'expenseTracker_expenses';
    this.backupKey = 'expenseTracker_expenses_bak';
  }
  
  async getAll() {
    try {
      const data = localStorage.getItem(this.storageKey);
      return JSON.parse(data) || [];
    } catch (error) {
      handleStorageError(error);
      return [];
    }
  }
  
  async add(expense) {
    const expenses = await this.getAll();
    await this.backup();
    
    const newExpense = {
      id: generateUUID(),
      ...expense,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    
    expenses.push(newExpense);
    localStorage.setItem(this.storageKey, JSON.stringify(expenses));
    return newExpense;
  }
  
  async update(id, data, originalUpdatedAt = null) {
    const expenses = await this.getAll();
    const index = expenses.findIndex(exp => exp.id === id);
    
    if (index === -1) {
      throw new Error('Expense not found');
    }
    
    // 競合チェック
    if (originalUpdatedAt && expenses[index].updatedAt !== originalUpdatedAt) {
      throw new ConflictError('Conflict detected', {
        current: expenses[index],
        attempted: data
      });
    }
    
    await this.backup();
    
    expenses[index] = {
      ...expenses[index],
      ...data,
      updatedAt: new Date().toISOString()
    };
    
    localStorage.setItem(this.storageKey, JSON.stringify(expenses));
    return expenses[index];
  }
  
  async delete(id) {
    const expenses = await this.getAll();
    await this.backup();
    
    const filtered = expenses.filter(exp => exp.id !== id);
    localStorage.setItem(this.storageKey, JSON.stringify(filtered));
    return true;
  }
  
  async clear() {
    await this.backup();
    localStorage.setItem(this.storageKey, JSON.stringify([]));
    return true;
  }
  
  async backup() {
    const expenses = await this.getAll();
    localStorage.setItem(this.backupKey, JSON.stringify(expenses));
  }
  
  async restore() {
    const backup = localStorage.getItem(this.backupKey);
    if (backup) {
      localStorage.setItem(this.storageKey, backup);
      return true;
    }
    return false;
  }
}

// アプリケーション内でStorageAdapterを使用
const storage = new LocalStorageAdapter();

// 将来的にクラウドストレージに移行する場合
// const storage = new CloudStorageAdapter(apiUrl, apiKey);
```

### 9.2 国際化（i18n）辞書の外部定義

UI文言をコードから分離し、多言語対応を容易にします。

```javascript
// i18n/ja.json（日本語辞書）
{
  "app": {
    "title": "支出記録アプリ",
    "totalExpense": "総支出"
  },
  "form": {
    "amount": "金額",
    "category": "カテゴリ",
    "date": "日付",
    "memo": "メモ",
    "submit": "追加",
    "cancel": "キャンセル"
  },
  "messages": {
    "addSuccess": "支出を追加しました",
    "updateSuccess": "支出を更新しました",
    "deleteSuccess": "支出を削除しました",
    "undo": "取り消し",
    "errors": {
      "amountInvalid": "金額は1円以上9,999,999円以下の整数で入力してください",
      "futureDate": "未来日は登録できません",
      "memoTooLong": "メモは100文字以内で入力してください（現在：{count}文字）"
    }
  },
  "empty": {
    "title": "最初の支出を追加しましょう",
    "addDummyData": "サンプルデータを追加"
  }
}

// i18n/en.json（英語辞書）
{
  "app": {
    "title": "Expense Tracker",
    "totalExpense": "Total Expense"
  },
  // ...
}

// i18nライブラリまたは軽量実装
class I18n {
  constructor(locale = 'ja') {
    this.locale = locale;
    this.messages = {};
  }
  
  async load() {
    const response = await fetch(`./i18n/${this.locale}.json`);
    this.messages = await response.json();
  }
  
  t(key, params = {}) {
    const keys = key.split('.');
    let value = this.messages;
    
    for (const k of keys) {
      value = value[k];
      if (!value) return key; // フォールバック
    }
    
    // パラメータ置換
    return value.replace(/\{(\w+)\}/g, (match, param) => params[param] || match);
  }
}

// 使用例
const i18n = new I18n('ja');
await i18n.load();

document.title = i18n.t('app.title');
showToast(i18n.t('messages.addSuccess'));
```

### 9.3 カテゴリマスタの外部定義（再掲）

カテゴリ定義を外部ファイル（`categories.json`）に分離し、拡張性を確保（7.4節参照）。

### 9.4 アーキテクチャ図

```
┌─────────────────────────────────────┐
│          UI Layer (HTML/CSS)        │
│  - Forms, Lists, Modals, Toasts     │
└─────────────────┬───────────────────┘
                  │
┌─────────────────▼───────────────────┐
│      Application Logic (JS)         │
│  - Event Handlers                   │
│  - Validation                       │
│  - Business Rules                   │
└─────────────────┬───────────────────┘
                  │
┌─────────────────▼───────────────────┐
│      StorageAdapter Interface       │
│  - getAll() / add() / update()      │
│  - delete() / clear()               │
│  - backup() / restore()             │
└─────────────────┬───────────────────┘
                  │
        ┌─────────┴─────────┐
        │                   │
┌───────▼────────┐  ┌───────▼────────┐
│ LocalStorage   │  │  CloudStorage  │
│    Adapter     │  │    Adapter     │
│   (Current)    │  │    (Future)    │
└────────────────┘  └────────────────┘
```

## 10. 今後の拡張案

### 10.1 優先度: 高

#### 多言語対応（i18n）
- **設計方針**:
  - カテゴリIDは言語非依存で保持（既に対応済み）
  - UI文言を言語ファイルに分離（`i18n/ja.json`, `i18n/en.json`）
  - ブラウザの言語設定またはユーザー選択に基づいて言語を切り替え
  - 日付・金額フォーマットも言語に応じて変更（`Intl` API使用）
- **対応言語候補**: 日本語、英語、中国語（簡体字・繁体字）
- **実装ライブラリ検討**: i18next、Vue I18n、React-Intl等

#### クラウド同期機能
- **設計方針**:
  - `createdAt`, `updatedAt` タイムスタンプを活用した競合解決
  - ローカルストレージとクラウドの双方向同期
  - 最終更新時刻が新しいデータを優先（Last-Write-Wins）
  - オフライン対応: ローカル優先、オンライン復帰時に同期
- **競合解決戦略**:
  - 同一IDで `updatedAt` が異なる場合、新しい方を採用
  - 削除済みデータの扱い: 論理削除フラグ（`isDeleted`）の導入検討
- **同期タイミング**:
  - アプリ起動時
  - データ変更後（デバウンス処理で一定時間後に同期）
  - 手動同期ボタン
- **技術候補**: Firebase Realtime Database、Supabase、AWS Amplify、自前REST API

### 10.2 優先度: 中

#### データ可視化
- 月次・年次レポート機能
- カテゴリ別支出の円グラフ・棒グラフ
- 時系列折れ線グラフ（支出推移）
- ライブラリ候補: Chart.js、Recharts、D3.js

#### 予算管理機能
- カテゴリ別・月次予算の設定
- 予算超過時の警告通知
- 予算達成率の可視化

#### データエクスポート・インポート
- CSV形式でのエクスポート・インポート
- JSON形式でのバックアップ・復元
- 他の家計簿アプリからのデータ移行サポート

### 10.3 優先度: 低

- カテゴリの追加・編集・削除機能（ユーザーカスタマイズ）
- 定期支出の自動登録機能
- レシート撮影・OCR機能
- ダークモード対応
- PWA化（オフライン動作強化、アプリインストール）
- 複数通貨対応
- タグ機能（カテゴリ以外の分類軸）
- データ分析・予測機能（AI活用）

### 10.4 アーキテクチャ拡張の考慮事項

#### 将来のバックエンド統合
- 現行のlocalStorageベースの設計を維持しつつ、データアクセス層を抽象化
- Repository パターンの導入:
  ```javascript
  class ExpenseRepository {
    async getAll() { /* localStorage or API */ }
    async add(expense) { /* localStorage or API */ }
    async update(id, data) { /* localStorage or API */ }
    async delete(id) { /* localStorage or API */ }
  }
  ```
- これにより、バックエンド追加時もフロントエンドのロジックを最小限の変更で対応可能

#### データマイグレーション
- 仕様変更時のデータバージョン管理
- localStorage内にスキーマバージョンを保存
- 旧バージョンデータの自動マイグレーション処理

---

**文書バージョン**: 1.3  
**作成日**: 2025年10月22日  
**最終更新日**: 2025年10月22日  
**変更履歴**: 
- v1.3 (2025-10-22): 検索機能拡張（カテゴリ名検索）、フィルター・ソート設定の永続化、日付入力ショートカット、削除確認ダイアログ廃止（Undo方式）、CSVエクスポート機能実装
- v1.2 (2025-10-22): ストレージ耐障害性、複数タブ対応、UUID採用、フィルター評価順序の明確化、UI/UX仕様具体化、アクセシビリティ強化、パフォーマンス要件追加、セキュリティ方針明確化、将来対応のための抽象化設計を追加
- v1.1 (2025-10-22): 入力バリデーション仕様の厳密化、カテゴリID管理の明確化、多言語・同期対応を考慮した設計に更新
